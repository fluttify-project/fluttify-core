package #__package_name__#

import android.os.Bundle
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.PluginRegistry.Registrar

val HEAP = mutableMapOf<Int, Any>()

@Suppress("FunctionName", "UsePropertyAccessSyntax", "RedundantUnitReturnType", "UNUSED_PARAMETER", "SpellCheckingInspection", "ConvertToStringTemplate", "DEPRECATION", "UNUSED_VARIABLE")
class #__plugin_name__#Plugin(private val registrar: Registrar): MethodChannel.MethodCallHandler {

    companion object {
        @JvmStatic
        fun registerWith(registrar: Registrar) {
            val channel = MethodChannel(registrar.messenger(), "#__method_channel__#")
            channel.setMethodCallHandler(#__plugin_name__#Plugin(registrar))

            // 注册View
            #__register_platform_views__#
        }
    }

    private val handlerMap = mapOf<String, (Registrar, Map<String, Any>, MethodChannel.Result) -> Unit>(
        #__handlers__#
    )

    override fun onMethodCall(methodCall: MethodCall, methodResult: MethodChannel.Result) {
        val args = methodCall.arguments as? Map<String, Any> ?: mapOf()
        when (methodCall.method) {
            // 获取Application对象
            "ObjectFactory::getandroid_app_Application" -> {
                methodResult.success(registrar.activity().application.apply { HEAP[hashCode()] = this }.hashCode())
            }
            // 获取FlutterActivity对象
            "ObjectFactory::getandroid_app_Activity" -> {
                methodResult.success(registrar.activity().apply { HEAP[hashCode()] = this }.hashCode())
            }
            // 创建android.os.Bundle对象
            "ObjectFactory::createandroid_os_Bundle" -> {
                methodResult.success(Bundle().apply { HEAP[hashCode()] = this }.hashCode())
            }
            // 释放一个对象
            "ObjectFactory::release" -> {
                HEAP.remove(args["refId"] as Int)
                methodResult.success("success")
            }
            // 清空HEAP中所有对象
            "ObjectFactory::clearRefMap" -> {
                HEAP.clear()
                methodResult.success("success")
            }
            else -> {
                handlerMap[methodCall.method]?.invoke(registrar, args, methodResult) ?: methodResult.notImplemented()
            }
        }
    }
}
